# cortex/sovereign/autopoiesis.py
"""Autopoiesis module for Sovereign Agentic Intelligence.

Provides the `Autopoiesis` class, enabling CORTEX agents to generate, test,
and register new utility scripts on-the-fly inside a sandboxed environment.
This embodies the 'self-creation' axiom: when the swarm needs a capability,
it architecturally manifests it.
"""

from __future__ import annotations

import logging
import os
import subprocess
import uuid
from collections.abc import Callable
from pathlib import Path

logger = logging.getLogger(__name__)


class Autopoiesis:
    """Self-creation engine for on-demand tools.

    Promoted from experimental to core sovereign layer.
    """

    def __init__(self, tool_dir: str | os.PathLike = "~/.cortex/tools") -> None:
        self.tool_dir = Path(os.path.expanduser(tool_dir))
        self.tool_dir.mkdir(parents=True, exist_ok=True)
        logger.info(f"Autopoiesis engine activated at {self.tool_dir}")

    def _execute_sandbox(self, script_path: Path) -> subprocess.CompletedProcess:
        """Execute a Python script inside a hardened environment.

        Scrubs environment variables to prevent sensitive data leakage (e.g. Master Key).
        """
        # Whitelist of safe environment variables
        # GPT-4o Wave Fix: Removed PYTHONPATH to prevent sandbox escape via malicious path injection.
        safe_env_keys = {"PATH", "LANG", "LC_ALL"}
        safe_env = {k: v for k, v in os.environ.items() if k in safe_env_keys}

        # Add basic CORTEX tool markers
        safe_env["CORTEX_TOOL"] = "1"
        safe_env["CORTEX_SANDBOX"] = "1"

        cmd = ["python3", str(script_path)]
        return subprocess.run(cmd, capture_output=True, text=True, timeout=30, env=safe_env)

    def generate_and_register(
        self,
        generator: Callable[[], str],
        validator: Callable[[str], bool] | None = None,
    ) -> Path:
        """Generate a script, execute it, and register it if valid."""
        source = generator()
        # GPT-4o Wave Fix: Increased entropy from 8 to 16 hex chars to prevent collisions and predictability.
        script_name = f"tool_{uuid.uuid4().hex[:16]}.py"
        script_path = self.tool_dir / script_name

        # Ensure header for sovereign tools
        if not source.startswith("#!"):
            source = f"# Generated by CORTEX Autopoiesis\n{source}"

        script_path.write_text(source, encoding="utf-8")
        logger.debug(f"Manifesting tool: {script_name}")

        result = self._execute_sandbox(script_path)
        if result.returncode != 0:
            logger.error(f"Autopoietic manifestation failed: {result.stderr}")
            raise RuntimeError(f"Sandbox execution failed: {result.stderr}")

        if validator is not None and not validator(result.stdout):
            logger.error("Validator rejected expressed tool output.")
            raise ValueError("Validator rejected script output")

        logger.info(f"Tool registered: {script_name}")
        return script_path

    def list_registered(self) -> list[Path]:
        """Return a list of all manifested tool scripts."""
        return list(self.tool_dir.glob("tool_*.py"))

    def remove_tool(self, script_path: Path) -> None:
        """Delete a previously manifested tool script."""
        try:
            script_path.unlink()
            logger.info(f"Tool recycled: {script_path.name}")
        except FileNotFoundError:
            pass

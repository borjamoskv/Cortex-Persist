{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CORTEX","text":"<p>Local-first sovereign memory infrastructure for AI agents.</p> <p>Semantic search, temporal queries, and hash-chained transaction ledger \u2014 all running locally on SQLite. Zero network dependencies.</p>"},{"location":"#why-cortex","title":"Why CORTEX?","text":"<ul> <li>\ud83e\udde0 Sovereign \u2014 Your data stays on your machine. No cloud, no API keys, no vendor lock-in.</li> <li>\u26a1 Sub-5ms embeddings \u2014 ONNX Runtime runs <code>all-MiniLM-L6-v2</code> locally.</li> <li>\u23f0 Temporal \u2014 Ask \"what did we know last Tuesday?\" with point-in-time queries.</li> <li>\ud83d\udd10 Tamper-proof \u2014 Every mutation is recorded in a hash-chained transaction ledger.</li> <li>\ud83d\udcca Observable \u2014 Built-in dashboard, time tracking, and daemon monitoring.</li> </ul>"},{"location":"#quick-install","title":"Quick Install","text":"<pre><code>pip install cortex-memory\n</code></pre> <pre><code>cortex init\ncortex store my-project \"FastAPI uses Pydantic for validation\" --tags \"fastapi,python\"\ncortex search \"how does validation work?\"\n</code></pre> <p>Get started \u2192 View on GitHub \u2192</p>"},{"location":"api/","title":"REST API Reference","text":"<p>CORTEX exposes a FastAPI-based REST API on port <code>8742</code>.</p>"},{"location":"api/#start-the-server","title":"Start the server","text":"<pre><code>pip install cortex-memory[api]\nuvicorn cortex.api:app --host 0.0.0.0 --port 8742\n</code></pre> <p>The interactive OpenAPI docs are available at <code>http://localhost:8742/docs</code>.</p>"},{"location":"api/#authentication","title":"Authentication","text":"<p>Some endpoints require an API key via the <code>X-API-Key</code> header. Keys are SHA-256 hashed before storage.</p> <pre><code># Create a key via the API\ncurl -X POST http://localhost:8742/auth/keys \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\": \"my-client\", \"permissions\": [\"read\", \"write\"]}'\n</code></pre>"},{"location":"api/#endpoints","title":"Endpoints","text":""},{"location":"api/#post-store","title":"<code>POST /store</code>","text":"<p>Store a fact.</p> <p>Request body:</p> <pre><code>{\n  \"project\": \"my-project\",\n  \"content\": \"Redis uses skip lists for sorted sets\",\n  \"fact_type\": \"knowledge\",\n  \"tags\": [\"redis\", \"data-structures\"],\n  \"confidence\": \"stated\",\n  \"source\": \"documentation\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"fact_id\": 42,\n  \"project\": \"my-project\",\n  \"tx_hash\": \"a1b2c3...\"\n}\n</code></pre>"},{"location":"api/#post-search","title":"<code>POST /search</code>","text":"<p>Semantic search.</p> <p>Request body:</p> <pre><code>{\n  \"query\": \"sorted set implementation\",\n  \"project\": null,\n  \"top_k\": 5,\n  \"as_of\": null\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"results\": [\n    {\n      \"fact_id\": 42,\n      \"project\": \"my-project\",\n      \"content\": \"Redis uses skip lists for sorted sets\",\n      \"fact_type\": \"knowledge\",\n      \"score\": 0.89,\n      \"tags\": [\"redis\", \"data-structures\"]\n    }\n  ]\n}\n</code></pre>"},{"location":"api/#get-recallproject","title":"<code>GET /recall/{project}</code>","text":"<p>Load all active facts for a project.</p> <p>Response:</p> <pre><code>{\n  \"project\": \"my-project\",\n  \"facts\": [...],\n  \"count\": 15\n}\n</code></pre>"},{"location":"api/#get-status","title":"<code>GET /status</code>","text":"<p>System health and statistics.</p> <p>Response:</p> <pre><code>{\n  \"version\": \"0.1.0\",\n  \"db_path\": \"/Users/you/.cortex/cortex.db\",\n  \"db_size_mb\": 2.4,\n  \"total_facts\": 150,\n  \"active_facts\": 142,\n  \"deprecated_facts\": 8,\n  \"project_count\": 5,\n  \"embeddings\": 142,\n  \"transactions\": 158\n}\n</code></pre>"},{"location":"api/#get-dashboard","title":"<code>GET /dashboard</code>","text":"<p>Embedded Industrial Noir dashboard with Chart.js visualizations.</p>"},{"location":"api/#post-heartbeat","title":"<code>POST /heartbeat</code>","text":"<p>Record an activity heartbeat for time tracking.</p> <p>Request body:</p> <pre><code>{\n  \"project\": \"my-project\",\n  \"entity\": \"src/main.py\",\n  \"category\": \"coding\",\n  \"branch\": \"feature/auth\"\n}\n</code></pre>"},{"location":"api/#get-time","title":"<code>GET /time</code>","text":"<p>Time tracking summary.</p> <p>Query parameters:</p> Parameter Default Description <code>project</code> \u2014 Filter by project <code>days</code> <code>1</code> Number of days"},{"location":"api/#post-deprecatefact_id","title":"<code>POST /deprecate/{fact_id}</code>","text":"<p>Soft-delete a fact.</p> <p>Query parameters:</p> Parameter Description <code>reason</code> Reason for deprecation"},{"location":"api/#error-handling","title":"Error Handling","text":"Status Meaning <code>200</code> Success <code>401</code> Missing or invalid API key <code>404</code> Resource not found <code>422</code> Validation error (e.g., empty project name) <code>500</code> Internal server error <p>All errors return:</p> <pre><code>{\n  \"detail\": \"Error description\"\n}\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>CORTEX is a local-first memory system. Everything runs on your machine \u2014 no cloud services, no API keys to external providers.</p> <pre><code>graph TB\n    subgraph Interfaces\n        CLI[CLI&lt;br/&gt;15 commands]\n        API[REST API&lt;br/&gt;FastAPI]\n        Dashboard[Dashboard&lt;br/&gt;Industrial Noir UI]\n    end\n\n    subgraph Core\n        Engine[Core Engine]\n        Search[Search Engine]\n        Embedder[ONNX Embedder&lt;br/&gt;all-MiniLM-L6-v2]\n        Auth[Auth Manager&lt;br/&gt;SHA-256 keys]\n        Temporal[Temporal Engine]\n    end\n\n    subgraph Storage\n        SQLite[(SQLite)]\n        Vec[sqlite-vec&lt;br/&gt;vector index]\n        Ledger[Hash-Chained&lt;br/&gt;Ledger]\n    end\n\n    subgraph Background\n        Daemon[Daemon&lt;br/&gt;MOSKV-1]\n        Sync[Sync Engine]\n        Timing[Time Tracker]\n    end\n\n    CLI --&gt; Engine\n    API --&gt; Engine\n    API --&gt; Auth\n    Dashboard --&gt; API\n\n    Engine --&gt; Search\n    Engine --&gt; Temporal\n    Search --&gt; Embedder\n    Search --&gt; Vec\n\n    Engine --&gt; SQLite\n    Engine --&gt; Ledger\n    Vec --&gt; SQLite\n\n    Daemon --&gt; Engine\n    Sync --&gt; Engine\n    Timing --&gt; SQLite\n    Sync --&gt; JSON[~/.agent/memory/]</code></pre>"},{"location":"architecture/#core-concepts","title":"Core Concepts","text":""},{"location":"architecture/#facts","title":"Facts","text":"<p>The fundamental unit of memory. A fact belongs to a project and has:</p> Field Description <code>content</code> The information (text) <code>project</code> Namespace (e.g., <code>my-api</code>) <code>fact_type</code> <code>knowledge</code>, <code>decision</code>, <code>error</code>, <code>config</code> <code>tags</code> JSON array of tags <code>confidence</code> <code>stated</code>, <code>inferred</code>, <code>observed</code> <code>valid_from</code> When the fact became true <code>valid_until</code> When the fact was deprecated (null = active)"},{"location":"architecture/#temporal-queries","title":"Temporal Queries","text":"<p>Every fact has a temporal window (<code>valid_from</code> \u2192 <code>valid_until</code>). This enables:</p> <ul> <li>Current view: Only facts where <code>valid_until IS NULL</code></li> <li>Point-in-time: Facts valid at a specific timestamp</li> <li>History: Full timeline including deprecated facts</li> </ul>"},{"location":"architecture/#hash-chained-ledger","title":"Hash-Chained Ledger","text":"<p>Every mutation (store, deprecate, edit) creates a transaction with a SHA-256 hash linked to the previous transaction. This creates a tamper-evident audit trail.</p> <pre><code>TX #1: hash = SHA256(data_1)\nTX #2: hash = SHA256(data_2 + hash_1)\nTX #3: hash = SHA256(data_3 + hash_2)\n...\n</code></pre>"},{"location":"architecture/#embeddings","title":"Embeddings","text":"<p>Text is embedded locally using <code>all-MiniLM-L6-v2</code> via ONNX Runtime (~5ms per embedding). Vectors are stored and indexed using <code>sqlite-vec</code> for fast cosine-similarity search.</p>"},{"location":"architecture/#data-model","title":"Data Model","text":"<pre><code>erDiagram\n    FACTS {\n        int id PK\n        text project\n        text content\n        text fact_type\n        text tags\n        text confidence\n        datetime valid_from\n        datetime valid_until\n        text source\n        text meta\n    }\n    EMBEDDINGS {\n        int fact_id FK\n        blob vector\n    }\n    TRANSACTIONS {\n        int id PK\n        text operation\n        int fact_id FK\n        text tx_hash\n        text prev_hash\n        datetime created_at\n    }\n    HEARTBEATS {\n        int id PK\n        text project\n        text entity\n        text category\n        datetime timestamp\n    }\n    TIME_ENTRIES {\n        int id PK\n        text project\n        text category\n        int duration_seconds\n        datetime start_time\n        datetime end_time\n    }\n\n    FACTS ||--o| EMBEDDINGS : \"has\"\n    FACTS ||--o{ TRANSACTIONS : \"tracked by\"\n    HEARTBEATS }o--|| TIME_ENTRIES : \"flushed to\"</code></pre>"},{"location":"architecture/#sync-architecture","title":"Sync Architecture","text":"<p>The sync engine maintains bidirectional consistency between JSON files in <code>~/.agent/memory/</code> and the CORTEX database:</p> <ol> <li>JSON \u2192 DB (<code>cortex sync</code>): Reads JSON files, hashes with SHA-256 to detect changes, upserts into DB</li> <li>DB \u2192 JSON (<code>cortex writeback</code>): Exports DB state back to JSON files</li> </ol> <p>Change detection uses a persistent sync state file that tracks file hashes, so only modified files are processed.</p>"},{"location":"architecture/#daemon-moskv-1","title":"Daemon (MOSKV-1)","text":"<p>The background daemon monitors:</p> <ul> <li>Site uptime \u2014 HTTP health checks on configured URLs</li> <li>Ghost state \u2014 Detects stale or abandoned projects</li> <li>Memory freshness \u2014 Alerts when memory hasn't been synced recently</li> <li>SSL certificates \u2014 Warns before expiry</li> <li>Disk usage \u2014 Alerts when storage is running low</li> </ul>"},{"location":"cli/","title":"CLI Reference","text":"<p>CORTEX provides 15 commands. Run <code>cortex --help</code> for the full list.</p>"},{"location":"cli/#global-options","title":"Global Options","text":"Option Description <code>--version</code> Show version and exit <code>--help</code> Show help and exit"},{"location":"cli/#cortex-init","title":"<code>cortex init</code>","text":"<p>Initialize the CORTEX database.</p> <pre><code>cortex init [--db PATH]\n</code></pre> Option Default Description <code>--db</code> <code>~/.cortex/cortex.db</code> Database path"},{"location":"cli/#cortex-store","title":"<code>cortex store</code>","text":"<p>Store a fact in CORTEX.</p> <pre><code>cortex store PROJECT CONTENT [OPTIONS]\n</code></pre> Argument/Option Default Description <code>PROJECT</code> required Project name <code>CONTENT</code> required Fact content <code>--type</code> <code>knowledge</code> Fact type (<code>knowledge</code>, <code>decision</code>, <code>error</code>, <code>config</code>) <code>--tags</code> \u2014 Comma-separated tags <code>--confidence</code> <code>stated</code> Confidence level <code>--source</code> \u2014 Source of the fact <code>--db</code> <code>~/.cortex/cortex.db</code> Database path <p>Example:</p> <pre><code>cortex store my-api \"Rate limit is 100 req/min per API key\" --type config --tags \"api,limits\"\n</code></pre>"},{"location":"cli/#cortex-search","title":"<code>cortex search</code>","text":"<p>Semantic search across CORTEX memory.</p> <pre><code>cortex search QUERY [OPTIONS]\n</code></pre> Option Default Description <code>--project</code>, <code>-p</code> \u2014 Scope to project <code>--top</code>, <code>-k</code> <code>5</code> Number of results <code>--db</code> <code>~/.cortex/cortex.db</code> Database path <p>Uses <code>all-MiniLM-L6-v2</code> embeddings via ONNX Runtime for sub-5ms vector search.</p>"},{"location":"cli/#cortex-recall","title":"<code>cortex recall</code>","text":"<p>Load full context for a project.</p> <pre><code>cortex recall PROJECT [--db PATH]\n</code></pre> <p>Returns all active facts grouped by type.</p>"},{"location":"cli/#cortex-history","title":"<code>cortex history</code>","text":"<p>Temporal query: what did we know at a specific time?</p> <pre><code>cortex history PROJECT [--at TIMESTAMP] [--db PATH]\n</code></pre> Option Description <code>--at</code> ISO 8601 timestamp for point-in-time query"},{"location":"cli/#cortex-status","title":"<code>cortex status</code>","text":"<p>Show CORTEX health and statistics.</p> <pre><code>cortex status [--db PATH] [--json-output]\n</code></pre> Option Description <code>--json-output</code> Output as JSON instead of table"},{"location":"cli/#cortex-list","title":"<code>cortex list</code>","text":"<p>List active facts in a table.</p> <pre><code>cortex list [OPTIONS]\n</code></pre> Option Default Description <code>--project</code>, <code>-p</code> \u2014 Filter by project <code>--type</code> \u2014 Filter by type <code>--limit</code>, <code>-n</code> <code>20</code> Max results"},{"location":"cli/#cortex-edit","title":"<code>cortex edit</code>","text":"<p>Edit a fact (deprecate old + create new with same metadata).</p> <pre><code>cortex edit FACT_ID NEW_CONTENT [--db PATH]\n</code></pre>"},{"location":"cli/#cortex-delete","title":"<code>cortex delete</code>","text":"<p>Soft-delete a fact (deprecate + auto write-back to JSON).</p> <pre><code>cortex delete FACT_ID [--reason TEXT] [--db PATH]\n</code></pre>"},{"location":"cli/#cortex-sync","title":"<code>cortex sync</code>","text":"<p>Synchronize <code>~/.agent/memory/</code> \u2192 CORTEX (incremental).</p> <pre><code>cortex sync [--db PATH]\n</code></pre> <p>Detects changes via SHA-256 hashing and only syncs modified files.</p>"},{"location":"cli/#cortex-export","title":"<code>cortex export</code>","text":"<p>Export a markdown snapshot for agent consumption.</p> <pre><code>cortex export [--db PATH] [--out PATH]\n</code></pre> Option Default Description <code>--out</code> <code>~/.cortex/context-snapshot.md</code> Output path"},{"location":"cli/#cortex-writeback","title":"<code>cortex writeback</code>","text":"<p>Write-back: CORTEX DB \u2192 <code>~/.agent/memory/</code> JSON files.</p> <pre><code>cortex writeback [--db PATH]\n</code></pre>"},{"location":"cli/#cortex-migrate","title":"<code>cortex migrate</code>","text":"<p>Import v3.1 data into v4.0.</p> <pre><code>cortex migrate [--source PATH] [--db PATH]\n</code></pre>"},{"location":"cli/#cortex-time","title":"<code>cortex time</code>","text":"<p>Show time tracking summary.</p> <pre><code>cortex time [--project PROJECT] [--days N] [--db PATH]\n</code></pre>"},{"location":"cli/#cortex-heartbeat","title":"<code>cortex heartbeat</code>","text":"<p>Record an activity heartbeat.</p> <pre><code>cortex heartbeat PROJECT [ENTITY] [OPTIONS]\n</code></pre> Option Description <code>--category</code>, <code>-c</code> Activity category (auto-classified if omitted) <code>--branch</code>, <code>-b</code> Git branch"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or later</li> <li>macOS, Linux, or Windows</li> </ul>"},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install cortex-memory\n</code></pre>"},{"location":"installation/#optional-extras","title":"Optional extras","text":"API ServerDevelopmentEverything <pre><code>pip install cortex-memory[api]\n</code></pre> <p>Includes FastAPI, Uvicorn, and HTTPX for the REST API and dashboard.</p> <pre><code>pip install cortex-memory[dev]\n</code></pre> <p>Includes pytest, pytest-cov, and HTTPX for testing.</p> <pre><code>pip install cortex-memory[all]\n</code></pre>"},{"location":"installation/#install-from-source","title":"Install from source","text":"<pre><code>git clone https://github.com/borjamoskv/cortex.git\ncd cortex\npip install -e \".[all]\"\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify installation","text":"<pre><code>cortex --version\n# cortex, version 0.1.0\n</code></pre>"},{"location":"installation/#first-steps","title":"First steps","text":"<pre><code>cortex init\ncortex status\n</code></pre> <p>This creates the database at <code>~/.cortex/cortex.db</code> and shows you the system health.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Get CORTEX running in 5 minutes.</p>"},{"location":"quickstart/#1-install","title":"1. Install","text":"<pre><code>pip install cortex-memory\n</code></pre> <p>For API server support:</p> <pre><code>pip install cortex-memory[api]\n</code></pre>"},{"location":"quickstart/#2-initialize","title":"2. Initialize","text":"<pre><code>cortex init\n</code></pre> <p>This creates <code>~/.cortex/cortex.db</code> with the full schema.</p>"},{"location":"quickstart/#3-store-facts","title":"3. Store Facts","text":"<pre><code># Store a knowledge fact\ncortex store my-project \"Redis uses skip lists for sorted sets\" --tags \"redis,data-structures\"\n\n# Store a decision\ncortex store my-project \"We chose FastAPI over Flask for async support\" --type decision\n\n# Store an error pattern\ncortex store my-project \"OOM when batch size &gt; 1024 on 8GB RAM\" --type error\n</code></pre>"},{"location":"quickstart/#4-search","title":"4. Search","text":"<p>Semantic search finds conceptually similar facts:</p> <pre><code>cortex search \"how are sorted sets implemented?\"\n\n# Scope to a specific project\ncortex search \"async web framework\" --project my-project\n</code></pre>"},{"location":"quickstart/#5-recall","title":"5. Recall","text":"<p>Load all active facts for a project:</p> <pre><code>cortex recall my-project\n</code></pre>"},{"location":"quickstart/#6-time-travel","title":"6. Time Travel","text":"<p>Query what you knew at a specific point in time:</p> <pre><code>cortex history my-project --at \"2026-01-15T10:00:00\"\n</code></pre>"},{"location":"quickstart/#7-api-server-optional","title":"7. API Server (Optional)","text":"<pre><code>uvicorn cortex.api:app --host 0.0.0.0 --port 8742\n</code></pre> <p>Then use the API:</p> <pre><code># Store via API\ncurl -X POST http://localhost:8742/store \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"project\": \"demo\", \"content\": \"CORTEX is running\", \"fact_type\": \"knowledge\"}'\n\n# Search via API\ncurl -X POST http://localhost:8742/search \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"query\": \"cortex\", \"top_k\": 5}'\n\n# Dashboard\nopen http://localhost:8742/dashboard\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>CLI Reference \u2014 All 15 commands documented</li> <li>API Reference \u2014 REST endpoints and models</li> <li>Architecture \u2014 How CORTEX works under the hood</li> </ul>"},{"location":"tutorials/daemon/","title":"Tutorial: Site Monitoring Daemon","text":"<p>Set up CORTEX's built-in daemon (MOSKV-1) to monitor your production sites.</p>"},{"location":"tutorials/daemon/#what-the-daemon-does","title":"What the Daemon Does","text":"<p>MOSKV-1 is a background watchdog that monitors:</p> <ul> <li>\ud83c\udf10 Site uptime \u2014 HTTP health checks with configurable intervals</li> <li>\ud83d\udc7b Ghost detection \u2014 Identifies stale or abandoned projects</li> <li>\ud83e\udde0 Memory freshness \u2014 Alerts when CORTEX hasn't been synced recently</li> <li>\ud83d\udd12 SSL certificates \u2014 Warns before certificate expiry</li> <li>\ud83d\udcbe Disk usage \u2014 Alerts on low storage</li> </ul>"},{"location":"tutorials/daemon/#start-the-daemon","title":"Start the Daemon","text":"<pre><code># Install with CLI\npip install cortex-memory\n\n# Start in background\nmoskv-daemon start\n\n# Check status\nmoskv-daemon status\n</code></pre>"},{"location":"tutorials/daemon/#configure-monitoring","title":"Configure Monitoring","text":"<p>The daemon configuration lives at <code>~/.cortex/daemon.yml</code>:</p> <pre><code># Sites to monitor\nsites:\n  - url: https://your-production-site.com\n    name: Production\n    interval: 60  # seconds\n    timeout: 10\n\n  - url: https://staging.your-site.com\n    name: Staging\n    interval: 300\n\n# Ghost detection\nghosts:\n  stale_threshold_days: 30\n  warn_threshold_days: 14\n\n# Memory freshness\nmemory:\n  sync_warn_hours: 24\n\n# SSL monitoring\nssl:\n  warn_days_before_expiry: 30\n\n# Disk monitoring\ndisk:\n  warn_threshold_percent: 90\n</code></pre>"},{"location":"tutorials/daemon/#receiving-alerts","title":"Receiving Alerts","text":"<p>On macOS, the daemon sends native notifications via <code>osascript</code>. You'll see alerts for:</p> <ul> <li>\ud83d\udd34 Site down \u2014 Immediate notification when a health check fails</li> <li>\ud83d\udfe1 SSL expiring \u2014 30 days before certificate expiry</li> <li>\ud83d\udc7b Stale project \u2014 When a project hasn't been updated in 30+ days</li> <li>\ud83d\udcbe Low disk \u2014 When disk usage exceeds 90%</li> </ul>"},{"location":"tutorials/daemon/#python-integration","title":"Python Integration","text":"<p>Use the daemon programmatically:</p> <pre><code>from cortex.daemon import CortexDaemon\nfrom cortex.engine import CortexEngine\n\nengine = CortexEngine()\nengine.init_db()\n\ndaemon = CortexDaemon(engine)\nstatus = daemon.check_all()\n\nif not status.all_healthy():\n    print(\"\u26a0\ufe0f Issues detected:\")\n    for alert in status.sites:\n        print(f\"  \ud83c\udf10 {alert.name}: {alert.message}\")\n    for alert in status.ghost_alerts:\n        print(f\"  \ud83d\udc7b {alert.project}: {alert.message}\")\n    for alert in status.cert_alerts:\n        print(f\"  \ud83d\udd12 {alert.domain}: {alert.message}\")\n</code></pre>"},{"location":"tutorials/daemon/#integrating-with-cicd","title":"Integrating with CI/CD","text":"<p>Add a health check to your deployment pipeline:</p> <pre><code># .github/workflows/health.yml\nname: Health Check\non:\n  schedule:\n    - cron: '*/15 * * * *'  # Every 15 minutes\n\njobs:\n  check:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - run: pip install cortex-memory\n      - run: |\n          python -c \"\n          from cortex.daemon import CortexDaemon\n          from cortex.engine import CortexEngine\n          engine = CortexEngine()\n          engine.init_db()\n          d = CortexDaemon(engine)\n          status = d.check_all()\n          assert status.all_healthy(), 'Health check failed!'\n          \"\n</code></pre>"},{"location":"tutorials/daemon/#best-practices","title":"Best Practices","text":"<p>Start simple</p> <p>Begin with just site monitoring, then add ghost detection and memory freshness as your CORTEX usage grows.</p> <p>Don't over-monitor</p> <p>Set reasonable intervals. 60 seconds for production, 5 minutes for staging. More frequent checks don't add value but increase resource usage.</p>"},{"location":"tutorials/langchain/","title":"Tutorial: Memory for LangChain Agents","text":"<p>Give your LangChain agent persistent, searchable memory backed by CORTEX.</p>"},{"location":"tutorials/langchain/#the-problem","title":"The Problem","text":"<p>LangChain's default memory is ephemeral \u2014 it disappears when your process dies. CORTEX gives you:</p> <ul> <li>Persistent memory that survives restarts</li> <li>Semantic search across past interactions</li> <li>Temporal queries to recall what the agent knew at any point</li> </ul>"},{"location":"tutorials/langchain/#setup","title":"Setup","text":"<pre><code>pip install cortex-memory langchain-openai\n</code></pre> <pre><code>from cortex.engine import CortexEngine\n\nengine = CortexEngine(db_path=\"~/.cortex/cortex.db\")\nengine.init_db()\n</code></pre>"},{"location":"tutorials/langchain/#store-agent-observations","title":"Store Agent Observations","text":"<p>After each agent step, store what it learned:</p> <pre><code>def store_observation(project: str, observation: str, tags: list[str] | None = None):\n    \"\"\"Store an agent observation in CORTEX.\"\"\"\n    engine.store(\n        project=project,\n        content=observation,\n        fact_type=\"knowledge\",\n        tags=tags,\n        source=\"langchain-agent\",\n    )\n</code></pre>"},{"location":"tutorials/langchain/#build-context-from-memory","title":"Build Context from Memory","text":"<p>Before each agent invocation, recall relevant context:</p> <pre><code>def build_context(project: str, query: str, top_k: int = 5) -&gt; str:\n    \"\"\"Search CORTEX for relevant past knowledge.\"\"\"\n    results = engine.search(query, project=project, top_k=top_k)\n\n    if not results:\n        return \"No relevant past observations found.\"\n\n    context_parts = []\n    for r in results:\n        context_parts.append(f\"- [{r.fact_type}] {r.content} (score: {r.score:.2f})\")\n\n    return \"## Relevant Past Knowledge\\n\" + \"\\n\".join(context_parts)\n</code></pre>"},{"location":"tutorials/langchain/#integration-with-langchain","title":"Integration with LangChain","text":"<pre><code>from langchain_openai import ChatOpenAI\nfrom langchain.schema import SystemMessage, HumanMessage\n\nllm = ChatOpenAI(model=\"gpt-4o\")\n\ndef agent_step(project: str, user_input: str) -&gt; str:\n    # 1. Search memory for context\n    context = build_context(project, user_input)\n\n    # 2. Build prompt with memory\n    messages = [\n        SystemMessage(content=f\"You are a helpful assistant.\\n\\n{context}\"),\n        HumanMessage(content=user_input),\n    ]\n\n    # 3. Get response\n    response = llm.invoke(messages)\n\n    # 4. Store the interaction as memory\n    store_observation(\n        project=project,\n        observation=f\"User asked: {user_input}. Agent answered: {response.content[:200]}\",\n        tags=[\"interaction\"],\n    )\n\n    return response.content\n</code></pre>"},{"location":"tutorials/langchain/#using-the-api-instead","title":"Using the API Instead","text":"<p>For distributed agents, use the REST API:</p> <pre><code>from cortex.client import CortexClient\n\nclient = CortexClient(base_url=\"http://localhost:8742\", api_key=\"your-key\")\n\n# Store\nclient.store(project=\"my-agent\", content=\"Learned that X does Y\")\n\n# Search\nresults = client.search(\"how does X work?\", top_k=3)\n</code></pre>"},{"location":"tutorials/langchain/#next-steps","title":"Next Steps","text":"<ul> <li>Use <code>cortex recall my-agent</code> to inspect everything your agent knows</li> <li>Use <code>cortex history my-agent --at \"2026-01-15\"</code> to see what it knew last week</li> <li>Use <code>cortex export</code> to create a context snapshot for cold starts</li> </ul>"},{"location":"tutorials/temporal/","title":"Tutorial: Time-Travel Debugging","text":"<p>Use CORTEX's temporal queries to understand what your system knew at any point in time.</p>"},{"location":"tutorials/temporal/#the-problem","title":"The Problem","text":"<p>Debugging production issues often requires answering: \"What was the configuration when this broke at 3 AM?\" CORTEX stores temporal metadata on every fact, enabling point-in-time recall.</p>"},{"location":"tutorials/temporal/#store-facts-with-temporal-awareness","title":"Store Facts with Temporal Awareness","text":"<p>Every fact gets a <code>valid_from</code> timestamp automatically:</p> <pre><code># January 15: store the current rate limit\ncortex store my-api \"Rate limit: 100 req/min\" --type config --tags \"rate-limit\"\n\n# February 1: update the rate limit (this deprecates the old fact)\ncortex edit 1 \"Rate limit: 500 req/min\"\n</code></pre>"},{"location":"tutorials/temporal/#query-points-in-time","title":"Query Points in Time","text":""},{"location":"tutorials/temporal/#cli","title":"CLI","text":"<pre><code># What did we know on January 20?\ncortex history my-api --at \"2026-01-20T00:00:00\"\n# \u2192 Shows: \"Rate limit: 100 req/min\" (was still active)\n\n# What did we know on February 5?\ncortex history my-api --at \"2026-02-05T00:00:00\"\n# \u2192 Shows: \"Rate limit: 500 req/min\" (updated version)\n</code></pre>"},{"location":"tutorials/temporal/#python","title":"Python","text":"<pre><code>from cortex.engine import CortexEngine\n\nengine = CortexEngine()\nengine.init_db()\n\n# Current state\ncurrent = engine.recall(\"my-api\")\n\n# State as of January 20\njanuary_state = engine.history(\"my-api\", as_of=\"2026-01-20T00:00:00\")\n</code></pre>"},{"location":"tutorials/temporal/#api","title":"API","text":"<pre><code>curl http://localhost:8742/recall/my-api?as_of=2026-01-20T00:00:00\n</code></pre>"},{"location":"tutorials/temporal/#debugging-workflow","title":"Debugging Workflow","text":"<ol> <li>Incident occurs at a specific time</li> <li>Query CORTEX for the state at that time:    <pre><code>cortex history production --at \"2026-02-10T03:15:00\"\n</code></pre></li> <li>Compare with current state:    <pre><code>cortex recall production\n</code></pre></li> <li>Identify what changed between then and now</li> </ol>"},{"location":"tutorials/temporal/#transaction-ledger","title":"Transaction Ledger","text":"<p>Every mutation is recorded in the hash-chained ledger, giving you a complete audit trail:</p> <pre><code>stats = engine.stats()\nprint(f\"Total transactions: {stats['transactions']}\")\n</code></pre> <p>Each transaction includes:</p> <ul> <li>Operation: <code>store</code>, <code>deprecate</code>, <code>edit</code></li> <li>Fact ID: Which fact was affected</li> <li>Hash: SHA-256 chain for tamper detection</li> <li>Timestamp: When the operation occurred</li> </ul>"},{"location":"tutorials/temporal/#best-practices","title":"Best Practices","text":"<p>Store configurations as facts</p> <p>When your system configuration changes, store the new values as facts. This creates a history of configuration states that you can query later.</p> <p>Use fact types for organization</p> <ul> <li><code>config</code> \u2014 System configuration values</li> <li><code>decision</code> \u2014 Architectural or operational decisions</li> <li><code>error</code> \u2014 Known error patterns and their resolutions</li> <li><code>knowledge</code> \u2014 General system knowledge</li> </ul>"}]}